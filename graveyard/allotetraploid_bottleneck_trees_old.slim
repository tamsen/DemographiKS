/*
	Allotetraploid bottleneck

	Example usage:

	slim -d "nuBot=0.1" -d "T1=0.5" -d "T2=0.25" -d "rep=1" allotetraploid_bottleneck.slim

	Parameters:
		nuBot: Proportion of the ancestral population size remaining after bottleneck.
		T1: The amount of time in dadi units (# of 2N generations) that the parents
			are isolated before forming the allotetraploid.
		T2: The amount of time the allotetraploid lineage has existed before we sample
			it.
		rep: Simulation replicate number (for running things in a for loop or
			 an array job on an HPC).
*/

initialize() {

	initializeTreeSeq(checkCoalescence=F);
	
	// Use the rep number to modify the starting seed.
	// Useful when running on a cluster with jobs starting at the same time.
	setSeed(rdunif(1, 0, asInteger(2^60) - 1)+asInteger(rep));
	
	// Number of ancestral individuals in population
	//defineConstant("Na", 1000);

	// Length of sequence (L)
	//defineConstant("L", 1e6);
	
	// Mutation rate
	//defineConstant("mu", 1.25e-6);
	defineConstant("mu", 0);
	
	// Burnin time (generally 10 * num chr = 10 * 2 * N)
	defineConstant("BurninTime", 10*2*Na);	

	// Bottleneck time (Schedule population bottleneck at generation (2N * T1)
	defineConstant("BottleneckTime",  2*Na * asFloat(T1));	
	
	// Sampling time (Schedule sampling time at (2N * (T1 + T2)))
	defineConstant("SamplingTime",   2*Na * (asFloat(T1) + asFloat(T2)));
	
	initializeMutationType("m1", 0.5, "f", 0.0);
	m1.convertToSubstitution = T;
	
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, L - 1);
	initializeMutationRate(mu);
	initializeRecombinationRate(1.25e-6);

	catn("BurninTime\t" + BurninTime);
}

/*
Setup initial diploid ancestral population with N individuals. Schedule population
bottleneck at generation (2N * T1) and sampling time at (2N * (T1 + T2)).
*/
1 early() {
	sim.addSubpop("p1", Na);
	community.rescheduleScriptBlock(
		s1,
		asInteger(BurninTime + BottleneckTime),
		asInteger(BurninTime + BottleneckTime)
		);
	community.rescheduleScriptBlock(
		s3,
		asInteger(BurninTime + SamplingTime),
		asInteger(BurninTime + SamplingTime)
		);
}

// Burn-in here is 10 * 2 * 1000 = 20_000 generations.
BurninTime: late() {
	catn(sim.cycle + "\t" + p1.individualCount + "\t" + p2.individualCount);
}

// Split populations after burn-in.
BurninTime early() {
	sim.addSubpopSplit("p2", Na, p1);
}

/*
Block is rescheduled in generation 1. This block is for starting the bottleneck.
*/
s1 10 late() {
	catn(sim.cycle  + "\t block s1 executed");
	catn(sim.cycle  + "\t starting the bottleneck");
	p1.setSubpopulationSize(asInteger(Nb));
	p2.setSubpopulationSize(asInteger(Nb));
}

s3 10 late() {
	catn(sim.cycle + "\t block s3 executed");
	sim.treeSeqOutput(trees_file_name);
	catn("wrote trees file to:\t" + trees_file_name);
}

/// print out population size///
1: late() {
	if(sim.cycle % 100 == 0) {
		
		num_p1 = size(p1.individuals);
		catn("size p1:\t" + num_p1 );
	}
}


asInteger(BurninTime + (2*Na * asFloat(T1))): late() {
	if(sim.cycle % 100 == 0) {
		
		num_p1 = size(p1.individuals);
		num_p2 = size(p2.individuals);
		catn("size p1:\t" + num_p1 );
		catn("size p2:\t" + num_p2 );
	}
}
