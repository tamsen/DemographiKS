// based on Peter Ralph, 10 September 2019
// Modified by Paul Blischak, 29 September 2020
// Modified by T Dunn

/*
	Diploid standard neutral model + output trees for TSKit

	Example usage:

	slim diploid_snm.slim

*/

initialize() {
	// Use the rep number to modify the starting seed.
	// Useful when running on a cluster with jobs starting at the same time.
	
	initializeTreeSeq(checkCoalescence=T);

	defineConstant("out_file_name", "/home/tamsen/Git/DemographiKS/DemographiKS/SLiM_output/diploid_snm.txt");
	defineConstant("trees_file_name", "/home/tamsen/Git/DemographiKS/DemographiKS/SLiM_output/diploid_trees.txt");		
	defineConstant("rep", 1);
	
	setSeed(rdunif(1, 0, asInteger(2^60) - 1)+asInteger(rep));
	
	// Number of individuals in population
	defineConstant("N", 100);

	// Length of sequence (L)
	defineConstant("L", 1e6);

	// Mutation rate
	//defineConstant("mu", 6.25e-7);
	defineConstant("mu", 0);	
	
	// When to output the Tree file to be read by tskit.load
	defineConstant("Tree_time", 2000);

	initializeMutationType("m1", 0.5, "f", 0.0);
	//m1.convertToSubstitution = T;

	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, L - 1);
	initializeMutationRate(mu);
	initializeRecombinationRate(6.25e-7);
}



/*
A population of diploids, neutral evolution
*/

1 early() {

	writeFile(out_file_name, "cycle,Ne,Coalesced,numMutations,pi_site,theoretical_theta",F);
	
	sim.addSubpop("p1", N);

}

// Print output every 50 generations.
late() {
	if (sim.cycle % 50 == 0){
		catn(sim.cycle);
	}
}

	
Tree_time late() {
	sim.treeSeqOutput(trees_file_name);
	catn("wrote trees file to:\t" + trees_file_name);	
}