// Peter Ralph, 10 September 2019: autotetraploidy
// Modified by Paul Blischak, 29 September 2020

/*
	Diploid standard neutral model

	Example usage:

	slim diploid_snm.slim

*/

initialize() {
	// Use the rep number to modify the starting seed.
	// Useful when running on a cluster with jobs starting at the same time.
	
	initializeTreeSeq(checkCoalescence=T);
	
	defineConstant("rep", 1);
	
	setSeed(rdunif(1, 0, asInteger(2^60) - 1)+asInteger(rep));
	
	// Number of individuals in population
	//defineConstant("N", 1000);
	defineConstant("N", 500);


	// Length of sequence (L)
	defineConstant("L", 1e6);

	// Mutation rate
	defineConstant("mu", 6.25e-7);

	initializeMutationType("m1", 0.5, "f", 0.0);
	m1.convertToSubstitution = T;

	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, L - 1);
	initializeMutationRate(mu);
	initializeRecombinationRate(6.25e-7);
}



/*
A population of diploids, neutral evolution
*/

1 early() {
	sim.addSubpop("p1", N);
	
	community.rescheduleScriptBlock(
		s2,
		asInteger(1));
}

// Print output every 50 generations.
//late() {
//	if (sim.cycle % 50 == 0){
//		catn(sim.cycle);
//	}
//}

/*
The burn-in period is typically 10x the total number of chromosomes in the
starting population. Since we're modeling a diploid with 
1000 individuals, that means that there are 2000 chromosomes and the burn-in
is 20_000 generations.
*/
50000 late() {
	/*
	  Here we go through and sample 20 chromosomes from the population. 
	  We then get the SFS using the following steps:

	    1. Find all positions that have mutations across both populations.
	    2. Tabulate the number of individuals with the mutation across all
	       possible positions.
	    3. Use the mutation counts to build the SFS.
	*/
	for(i in 1:50){
		// Sample individuals from pop1
		pop1_ind = sample(p1.individuals, 10, T);
	
		mutSum = rep(0, size(sim.mutations));
		for (ind in c(pop1_ind)) {
			for (g in ind.genomes) {
				mutSum = mutSum + asInteger(g.containsMutations(sim.mutations));
			}
		}

		// Get the SFS by tabulating how often we see mutations with
		// different frequencies.
		sfs = rep(0,2 * size(pop1_ind)+1);
		for(mut in mutSum){
			sfs[mut] = sfs[mut] + 1;
		}

		// compute diversity at segregating sites
		//Ne = 4 * length(pop1_ind);
		//p = mutSum / (2 * length(pop1_ind));
		//p = p[p > 0 & p < 1];
		//pi = mean(2 * p * (1-p));
		//catn("The mean diversity at segregating sites among " + length(pop1_ind) + " individuals is: " + pi);
		//catn("The mean diversity over the whole genome is " + pi * length(p) / L);
		//catn("... and the value expected from theory is " + 8 * p1.individualCount * mu);
		//catn("ratio = " + (pi * length(p) / L) / (8 * p1.individualCount * mu));

		// Write the file in dadi format
		//writeFile("diploid_snm2_"+ rep + "_" +i+".fs", "21 unfolded\n" + paste(sfs, " ") + "\n");
	}
}




/// CHECK FOR COALESCENCE ///
s2 1: late() {
	if(sim.cycle % 1000 == 0) {
		if(sim.treeSeqCoalesced()) {
			// record when coalescence happened
			//defineConstant("t_coalescence", asInteger(sim.cycle));
			catn(sim.cycle + ": COALESCED");
		}
		else
		{
			catn(sim.cycle+"\t: NOT COALESCED");
		}
		
		
		// Sample individuals from pop1
		pop1_ind = sample(p1.individuals, 10, T);
		
		mutSum = rep(0, size(sim.mutations));
		for (ind in c(pop1_ind)) {
			for (g in ind.genomes) {
				mutSum = mutSum + asInteger(g.containsMutations(sim.mutations));
			}
		}
		
		// compute diversity at segregating sites
		//N = 4 * length(pop1_ind);
		p = mutSum / (4 * length(pop1_ind));
		p = p[p > 0 & p < 1];
		pi = mean(2 * p * (1-p));
		catn("The mean diversity at segregating sites among " + length(pop1_ind) + " individuals is: \t" + pi);
		catn("The mean diversity over the whole genome:\t" + pi * length(p) / L);
		catn("The mean expected diversity (from theory):\t" + 8 * p1.individualCount * mu);
	}
}