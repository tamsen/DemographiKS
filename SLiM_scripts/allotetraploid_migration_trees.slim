/*
	Allotetraploid bottleneck

	Example usage:

	slim -d "nuBot=0.1" -d "T1=0.5" -d "T2=0.25" -d "rep=1" allotetraploid_bottleneck.slim

	Parameters:
		nuBot: Proportion of the ancestral population size remaining after bottleneck.
		T1: The amount of time in dadi units (# of 2N generations) that the parents
			are isolated before forming the allotetraploid.
		T2: The amount of time the allotetraploid lineage has existed before we sample
			it.
		rep: Simulation replicate number (for running things in a for loop or
			 an array job on an HPC).

	Code sourced from:
	P. D. Blischak, M. Sajan, M. S. Barker, R. N. Gutenkunst, Demographic history
    inference and the polyploid continuum. Genetics 224, iyad107 (2023).
    with minor modification.

*/

initialize() {

	initializeTreeSeq(checkCoalescence=F);

	// Use the rep number to modify the starting seed.
	// Useful when running on a cluster with jobs starting at the same time.
	setSeed(rdunif(1, 0, asInteger(2^60) - 1)+asInteger(rep));

	// Number of individuals in population
	defineConstant("N", asInteger(Na));

	// Time parents are isolated in generations
	defineConstant("T1", asFloat(delta_t));

	// Recombination rate
	defineConstant("RCR", asFloat(recombination_rate));

	// Burnin time (generally 10 * num chr = 10 * 2 * N)
	//defineConstant("BurninTime", 10*2*N);

	// Mutation rate
	defineConstant("mu", 0);

	initializeMutationType("m1", 0.5, "f", 0.0);
	m1.convertToSubstitution = T;

	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, L - 1);
	initializeMutationRate(mu);
	//initializeRecombinationRate(1.25e-6);
	initializeRecombinationRate(RCR);

	catn("Tdiv:\t" + Tdiv_gen);
	catn("delta_t:\t" + delta_t);

	//Migration-specific parameters
	defineConstant("MigStartInt", asInteger(MigStart));
	defineConstant("MigStopInt", asInteger(MigStop));
	defineConstant("MigRateFloat", asFloat(MigRate));
}

/*
Setup initial diploid ancestral population with N individuals. Schedule population
bottleneck at generation (2N * T1) and sampling time at (2N * (T1 + T2)).
*/
1 early() {
	sim.addSubpop("p1", N);
	community.rescheduleScriptBlock(
		s1,
		asInteger(BurninTime + asFloat(T1)),
		asInteger(BurninTime + asFloat(T1))
	);
	community.rescheduleScriptBlock(
		s3,
	    asInteger(BurninTime) +  asInteger(Tdiv_gen),
		asInteger(BurninTime) +  asInteger(Tdiv_gen)
	);
	community.rescheduleScriptBlock(
		s4,
	    asInteger(BurninTime-1),
		asInteger(BurninTime-1)
	);
	community.rescheduleScriptBlock(
		s5,
	    asInteger(BurninTime) + MigStartInt,
		asInteger(BurninTime) + MigStartInt
	);
	community.rescheduleScriptBlock(
		s6,
	    asInteger(BurninTime) + MigStopInt,
		asInteger(BurninTime) + MigStopInt
	);

}

// Burn-in here is 10 * 2 * 1000 = 20_000 generations.
BurninTime: late() {
	catn(sim.cycle + "\t" + p1.individualCount + "\t" + p2.individualCount);
}

// Split populations after burn-in.
BurninTime early() {
	catn(sim.cycle + "\tBurnin complete. Parental divergence start!");
	sim.addSubpopSplit("p2", N, p1);
}

s5 late() {
	catn(sim.cycle + "\t Its s5 time! Migration start!");
	catn("size p2=" + p2.individualCount);
	p1.setMigrationRates(p2, MigRateFloat);
    p2.setMigrationRates(p1, MigRateFloat);
    catn("set p2 to p1 migration rate.. " + MigRateFloat);
}

// Block is rescheduled in generation 1.
// This block stops migration between the parental populations
s6 late() {
	catn(sim.cycle + "\t Its s6 time! Migration stop!");
    p1.setMigrationRates(p2,0);
    p2.setMigrationRates(p1,0);
}

/*
Block is rescheduled in generation 1. This block is for starting the bottleneck.
*/
s1 10 late() {
	catn(sim.cycle + "\t Its s1 time! WGD has occurred!");
	p1.setSubpopulationSize(asInteger(Nb));
	p2.setSubpopulationSize(asInteger(Nb));
}

s3 10 late() {
	catn(sim.cycle + "\t block s3 executed");
	sim.treeSeqOutput(trees_file_name);
	catn("wrote trees file to:\t" + trees_file_name);
}
s4 10 late() {
	catn(sim.cycle + "\t block s4 executed");
	sim.treeSeqOutput(trees_file_name_at_div);
	catn("wrote trees file to:\t" + trees_file_name_at_div);
}