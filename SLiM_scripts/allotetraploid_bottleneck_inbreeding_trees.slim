/*
	Allotetraploid bottleneck

	Example usage:

	slim -d "nuBot=0.1" -d "T1=0.5" -d "T2=0.25" -d "rep=1" allotetraploid_bottleneck.slim

	Parameters:
		nuBot: Proportion of the ancestral population size remaining after bottleneck.
		T1: The amount of time in dadi units (# of 2N generations) that the parents
			are isolated before forming the allotetraploid.
		T2: The amount of time the allotetraploid lineage has existed before we sample
			it.
		rep: Simulation replicate number (for running things in a for loop or
			 an array job on an HPC).
*/

initialize() {

    initializeSLiMOptions(keepPedigrees=T);
	initializeTreeSeq(checkCoalescence=F);

	// Use the rep number to modify the starting seed.
	// Useful when running on a cluster with jobs starting at the same time.
	setSeed(rdunif(1, 0, asInteger(2^60) - 1)+asInteger(rep));

	// Number of individuals in population
	defineConstant("N", asInteger(Na));

	// Time parents are isolated in generations
	defineConstant("T1", asFloat(delta_t));

	// Recombination rate
	defineConstant("RCR", asFloat(recombination_rate));

	// Mutation rate
	defineConstant("mu", 0);

	// assortative_mating_coefficient
	defineConstant("AMCp", asFloat(AMCoef));
	defineConstant("AMCq", 1.0-AMCp);

	initializeMutationType("m1", 0.5, "f", 0.0);
	m1.convertToSubstitution = T;

	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, L - 1);
	initializeMutationRate(mu);
	//initializeRecombinationRate(1.25e-6);
	initializeRecombinationRate(RCR);

	catn("Tdiv:\t" + Tdiv_gen);
	catn("delta_t:\t" + delta_t);
	catn("AMCp:\t" + AMCp);
	catn("AMCq:\t" + AMCq);
}

1: late() {
	if(sim.cycle % 100 == 0) {
		catn("cycle:\t" + sim.cycle + "\tNe\t" + p1.individualCount);
		mean_relatedness=mean(p1.individuals.tagF);
		catn("mean_relatedness\t" + mean_relatedness + "\n");
		}
}


modifyChild()
{
	parental_relatedness=parent1.relatedness(c(parent2));
	child.tagF=parental_relatedness;
	return T;
}

mateChoice() {
    // Prefer relatives as mates
    // This particular callback makes the mating weights be (almost) proportional to relatedness.
    // The "0.00001" is a fudge to prevent the weights all ever being zero
    // (see SLiM manual for why this is needed)
	new_weights=weights*(AMCq + individual.relatedness(sourceSubpop.individuals)*AMCp + 0.00001)	;
	return new_weights;
}

/*
Setup initial diploid ancestral population with N individuals. Schedule population
bottleneck at generation (2N * T1) and sampling time at (2N * (T1 + T2)).
*/
1 early() {
	sim.addSubpop("p1", N);
	community.rescheduleScriptBlock(
		s1,
		asInteger(BurninTime + asFloat(T1)),
		asInteger(BurninTime + asFloat(T1))
	);
	community.rescheduleScriptBlock(
		s3,
	    asInteger(BurninTime) +  asInteger(Tdiv_gen),
		asInteger(BurninTime) +  asInteger(Tdiv_gen)
	);
	community.rescheduleScriptBlock(
		s4,
	    asInteger(BurninTime-1),
		asInteger(BurninTime-1)
	);


}


BurninTime: late() {
	if(sim.cycle % 100 == 0) {
	catn(sim.cycle + "\t" + p1.individualCount + "\t" + p2.individualCount);
	}
}

// Split populations after burn-in.
BurninTime early() {
	catn(sim.cycle + "\tBurnin complete. Parental divergence start!");
	sim.addSubpopSplit("p2", N, p1);
}

/*
Block is rescheduled in generation 1. This block is for starting the bottleneck.
*/
s1 10 late() {
	catn(sim.cycle + "\t Its s1 time! Starting WGD and bottleneck!");
	p1.setSubpopulationSize(asInteger(Nb));
	p2.setSubpopulationSize(asInteger(Nb));
	catn("size p2=" + p2.individualCount);
}

s3 10 late() {
	catn(sim.cycle + "\t block s3 executed");
	sim.treeSeqOutput(trees_file_name);
	catn("wrote trees file to:\t" + trees_file_name);
}
s4 10 late() {
	catn(sim.cycle + "\t block s4 executed");
	sim.treeSeqOutput(trees_file_name_at_div);
	catn("wrote trees file to:\t" + trees_file_name_at_div);
}